# Vulnerability Remediation: Why Agents Don't Patch Code (and How to Fix It)

## Problem Statement

When a user runs `esprit scan ./my-local-project` (white-box mode), the agent discovers vulnerabilities in the source code but **never patches them** — even though the system prompt (line 98) says:

> "FIX discovered vulnerabilities in code in same file."

The `str_replace_editor` tool is fully functional, registered, and passed to the LLM on every call. The agent simply never invokes it.

---

## Root Cause Analysis

There are **three compounding gaps** that prevent remediation from happening.

### Gap 1: The System Prompt Says "FIX" But Never Says How

The white-box instructions at `system_prompt.jinja:90-101` tell the agent to fix vulnerabilities, but never mention the tool it should use:

```
WHITE-BOX TESTING (code provided):
- FIX discovered vulnerabilities in code in same file.        ← line 98
- Test patches to confirm vulnerability removal.              ← line 99
- Do not stop until all reported vulnerabilities are fixed.   ← line 100
- Include code diff in final report.                          ← line 101
```

Meanwhile, every scanning tool is named explicitly in the prompt — `nmap`, `sqlmap`, `nuclei`, `ffuf`, `httpx`, `katana`, etc. (lines 340-394). But `str_replace_editor` appears **zero times** in the entire system prompt.

The agent has the tool available via JSON schema in the API call, but with native tool calling enabled (`native_tools_enabled = True`), the XML tool descriptions are NOT injected into the prompt (line 332-334). So the agent must infer from the JSON schema alone that it should use this tool for patching — which it never does, because the prompt gives it no reason to.

### Gap 2: No Remediation Skill Exists

The `esprit/skills/` directory contains 17 vulnerability *testing* skills:

```
vulnerabilities/
  sql_injection.md           ← how to FIND SQLi
  xss.md                     ← how to FIND XSS
  idor.md                    ← how to FIND IDOR
  ssrf.md                    ← how to FIND SSRF
  rce.md                     ← how to FIND RCE
  ...17 total
```

There is **zero** remediation/fixing skills. No `remediation.md`, no `code_patching.md`, no `vulnerability_fixing.md`. The agent has deep knowledge about how to discover vulnerabilities but no knowledge about how to fix them.

### Gap 3: The Multi-Agent Workflow Stops at Reporting

The system prompt defines a mandatory multi-agent workflow (`system_prompt.jinja:248-270`):

**Black-box workflow (lines 250-259):**
```
Discovery Agent → Validation Agent → Reporting Agent → STOP
```

**White-box workflow (lines 261-270):**
```
Discovery Agent → Validation Agent → Reporting Agent → Fixing Agent
```

The white-box diagram *shows* a 4th agent ("Auth Fixing Agent") but the enforcement only covers agents 1-3:

- Line 279: `"ONLY REPORTING AGENTS can use create_vulnerability_report tool"` — constrains reporting
- Line 147-149: `"Do NOT patch/fix before reporting"` — constrains ordering
- **No line constrains or instructs the spawning of a Fixing Agent after reporting**

The Reporting Agent calls `create_vulnerability_report`, then calls `agent_finish`. The root agent moves to the next vulnerability or calls `finish_scan`. The Fixing Agent step in the diagram is aspirational — it's documented but not enforced.

---

## Technical Proof: The Tool Chain Works

The `str_replace_editor` tool is fully wired end-to-end. Nothing is broken — it's just never called.

### Registration
| Step | File | Line(s) | What Happens |
|------|------|---------|-------------|
| Definition | `file_edit_actions.py` | 23-58 | `@register_tool def str_replace_editor(command, path, ...)` |
| XML Schema | `file_edit_actions_schema.xml` | 61-169 | Full parameter spec with `create`, `str_replace`, `insert`, `view`, `undo_edit` |
| Import (non-sandbox) | `tools/__init__.py` | 37 | `from .file_edit import *` |
| Import (sandbox) | `tools/__init__.py` | 52 | `from .file_edit import *` |
| Register to global list | `registry.py` | 281 | `tools.append(func_dict)` |
| JSON schema generated | `registry.py` | 276-279 | `_xml_to_json_schema("str_replace_editor", xml)` |

### Delivery to LLM
| Step | File | Line(s) | What Happens |
|------|------|---------|-------------|
| Agent fetches tools | `base_agent.py` | 538-549 | `_get_agent_tools()` → calls `get_tools_json()` |
| All tools returned | `registry.py` | 322-337 | `get_tools_json(tool_names=None)` — no filtering |
| Passed to generate | `base_agent.py` | 458 | `self.llm.generate(history, tools=tools)` |
| Forwarded to stream | `llm.py` | 213 | `self._stream(messages, tools=tools)` |
| Included in API call | `llm.py` | 544-545 | `args["tools"] = tools` in `_build_completion_args()` |
| Sent to litellm | `llm.py` | 247 | `acompletion(**args, stream=True)` |

### Execution (if it were ever called)
| Step | File | Line(s) | What Happens |
|------|------|---------|-------------|
| Tool call parsed | `llm.py` | 676-699 | `_extract_native_tool_calls(response)` |
| Actions extracted | `base_agent.py` | 482 | `actions = final_response.tool_invocations` |
| Tool dispatched | `executor.py` | 315-377 | `process_tool_invocations(actions, ...)` |
| Tool executed | `executor.py` | 31-38 | `execute_tool("str_replace_editor", **args)` |
| File edited | `file_edit_actions.py` | 24-58 | `str_replace_editor(command="str_replace", ...)` |

**The entire pipeline is functional.** The LLM receives `str_replace_editor` in its `tools` array on every API call. It simply never invokes it because the system prompt provides no instruction, no example, and no authority to do so.

---

## What Actually Happens During a White-Box Scan

### Expected (per system prompt line 98)
```
1. Root Agent spawns "SQLi Discovery Agent"
2. Discovery Agent finds SQL injection at app.py:42
3. Spawns "SQLi Validation Agent" → proves it with PoC
4. Spawns "SQLi Reporting Agent" → calls create_vulnerability_report
5. Spawns "SQLi Fixing Agent" → calls str_replace_editor to patch
6. Fixing Agent re-runs PoC → confirms vulnerability is gone
7. Moves to next vulnerability
```

### Actual
```
1. Root Agent spawns "SQLi Discovery Agent"
2. Discovery Agent finds SQL injection at app.py:42
3. Spawns "SQLi Validation Agent" → proves it with PoC
4. Spawns "SQLi Reporting Agent" → calls create_vulnerability_report
5. Reporting Agent calls agent_finish ← STOPS HERE
6. Root agent moves to next vulnerability or calls finish_scan
7. str_replace_editor was never called
8. Vulnerability remains unpatched in code
```

---

## Proposed Implementation

### Change 1: Add Explicit Tool Instructions to System Prompt

Add a `VULNERABILITY REMEDIATION` section after the white-box instructions (after line 101 in `system_prompt.jinja`):

```jinja2
VULNERABILITY REMEDIATION (how to fix code):
- Use the `str_replace_editor` tool to patch vulnerable code directly in the source files.
- Use `list_files` to navigate the project structure and locate relevant source files.
- Use `search_files` to find all occurrences of a vulnerable pattern across the codebase.
- Remediation workflow:
  1. Report the vulnerability first via `create_vulnerability_report`
  2. Read the vulnerable file with `str_replace_editor` (command="view")
  3. Apply the fix with `str_replace_editor` (command="str_replace", old_str="vulnerable code", new_str="fixed code")
  4. Verify the fix by re-running the exploit — it should no longer succeed
  5. If the same pattern exists in other files, use `search_files` to find them and patch each one
- Common fix patterns:
  - SQL Injection: Replace string concatenation with parameterized queries
  - XSS: Add output encoding/escaping at render points
  - IDOR: Add authorization checks before object access
  - SSRF: Validate and allowlist URLs before server-side requests
  - RCE: Replace eval/exec with safe alternatives, sanitize inputs to system commands
- ALWAYS test that your patch does not break existing functionality
- NEVER leave a discovered vulnerability unpatched in white-box mode
```

**Why this works:** LLMs follow explicit tool-name instructions far more reliably than implicit expectations. Naming `str_replace_editor` directly, with parameter examples (`command="str_replace"`, `old_str=...`, `new_str=...`), gives the agent a concrete action to take.

### Change 2: Enforce Fixing Agent Spawning in White-Box Workflow

Update the `CRITICAL RULES` section (around line 272) to add:

```jinja2
- **WHITE-BOX FIXING IS MANDATORY** - After a Reporting Agent completes in white-box mode,
  the parent agent MUST spawn a Fixing Agent that uses `str_replace_editor` to patch the
  vulnerable code and verify the fix. Do NOT call agent_finish until the fix is confirmed.
```

Update the white-box workflow diagram (lines 261-270) to be more explicit:

```jinja2
WHITE-BOX WORKFLOW (source code provided):
```
Authentication Code Agent finds weak password validation
    ↓
Spawns "Auth Validation Agent" (proves it's exploitable)
    ↓
If valid → Spawns "Auth Reporting Agent" (creates vulnerability report)
    ↓
MANDATORY → Spawns "Auth Fixing Agent" with instructions:
  - Use str_replace_editor to patch the vulnerable code
  - Re-run the original exploit to confirm it no longer works
  - Call agent_finish with the diff summary
```
```

### Change 3: Create a Remediation Skill

Create `esprit/skills/vulnerabilities/remediation.md`:

```markdown
---
name: remediation
description: Code vulnerability remediation using str_replace_editor
---

# Vulnerability Remediation

Guide for fixing discovered vulnerabilities directly in source code using the
`str_replace_editor` tool.

## Remediation Workflow

1. **Understand the vulnerability** — read the vulnerability report and the affected code
2. **Locate all instances** — use `search_files` to find the vulnerable pattern everywhere
3. **Apply the fix** — use `str_replace_editor` with `command="str_replace"`
4. **Verify the fix** — re-run the original exploit; it should fail
5. **Check for regressions** — run the app's test suite if available

## Fix Patterns by Vulnerability Type

### SQL Injection
**Vulnerable:**
```python
query = f"SELECT * FROM users WHERE id = {user_id}"
cursor.execute(query)
```
**Fixed:**
```python
query = "SELECT * FROM users WHERE id = %s"
cursor.execute(query, (user_id,))
```

### Cross-Site Scripting (XSS)
**Vulnerable:**
```python
return f"<div>{user_input}</div>"
```
**Fixed:**
```python
from markupsafe import escape
return f"<div>{escape(user_input)}</div>"
```

### Insecure Direct Object Reference (IDOR)
**Vulnerable:**
```python
@app.get("/api/users/{user_id}/profile")
def get_profile(user_id: int):
    return db.get_user(user_id)
```
**Fixed:**
```python
@app.get("/api/users/{user_id}/profile")
def get_profile(user_id: int, current_user = Depends(get_current_user)):
    if current_user.id != user_id and not current_user.is_admin:
        raise HTTPException(status_code=403)
    return db.get_user(user_id)
```

### Server-Side Request Forgery (SSRF)
**Vulnerable:**
```python
resp = requests.get(user_provided_url)
```
**Fixed:**
```python
from urllib.parse import urlparse

ALLOWED_HOSTS = {"api.example.com", "cdn.example.com"}

parsed = urlparse(user_provided_url)
if parsed.hostname not in ALLOWED_HOSTS:
    raise ValueError("URL not in allowlist")
resp = requests.get(user_provided_url)
```

### Remote Code Execution (RCE)
**Vulnerable:**
```python
result = eval(user_expression)
```
**Fixed:**
```python
import ast
result = ast.literal_eval(user_expression)
```

### Path Traversal
**Vulnerable:**
```python
filepath = os.path.join(UPLOAD_DIR, filename)
return open(filepath).read()
```
**Fixed:**
```python
filepath = os.path.join(UPLOAD_DIR, filename)
filepath = os.path.realpath(filepath)
if not filepath.startswith(os.path.realpath(UPLOAD_DIR)):
    raise ValueError("Path traversal detected")
return open(filepath).read()
```

## str_replace_editor Usage

### View a file
```
str_replace_editor(command="view", path="/workspace/app.py")
```

### Replace vulnerable code
```
str_replace_editor(
    command="str_replace",
    path="/workspace/app.py",
    old_str='query = f"SELECT * FROM users WHERE id = {user_id}"',
    new_str='query = "SELECT * FROM users WHERE id = %s"'
)
```

### Create a new file (e.g., a security utility)
```
str_replace_editor(
    command="create",
    path="/workspace/security_utils.py",
    file_text="from markupsafe import escape\n\ndef sanitize(input_str):\n    return escape(input_str)\n"
)
```

### Undo a bad edit
```
str_replace_editor(command="undo_edit", path="/workspace/app.py")
```

## Verification Checklist

After patching, always verify:
- [ ] Original exploit no longer succeeds
- [ ] Application still functions correctly (no regressions)
- [ ] Fix addresses the root cause, not just the symptom
- [ ] Same pattern doesn't exist elsewhere in the codebase
- [ ] Fix follows the project's existing code style and conventions
```

### Change 4: Add "remediation" to Fixing Agent Skill Set

When the system prompt instructs agents to spawn a Fixing Agent, the agent description should include the `remediation` skill. The workflow in `system_prompt.jinja` should show:

```jinja2
Spawns "Auth Fixing Agent" with skills: [remediation, authentication_jwt]
```

This ensures the Fixing Agent receives the remediation skill's knowledge base, including exact `str_replace_editor` usage patterns.

---

## Impact Assessment

### Without these changes
- White-box scans find vulnerabilities but leave them unpatched
- System prompt says "FIX" but agents have no mechanism to do so
- `str_replace_editor` is registered, schema'd, and passed to the LLM on every call — but never invoked
- Users must manually patch after reviewing the scan report

### With these changes
- Reporting Agent completes → parent agent spawns Fixing Agent
- Fixing Agent has explicit instructions + skill knowledge to use `str_replace_editor`
- Agent patches the code, re-runs the exploit, confirms the fix
- Final report includes the diff
- Users get a patched codebase alongside the vulnerability report

### Risk considerations
- **False fixes**: Agent might apply an incorrect patch. Mitigated by the "verify the fix" step (re-run exploit)
- **Breaking changes**: Agent might break functionality. Mitigated by `undo_edit` command and the instruction to run tests
- **Scope creep**: Agent might over-patch (refactoring beyond the vulnerability). Mitigated by "ONE AGENT = ONE TASK" rule
- **Agent cap**: Each Fixing Agent counts toward the `MAX_AGENTS = 10` limit. For codebases with many vulnerabilities, this could be a bottleneck

---

## Files to Modify

| File | Change | Priority |
|------|--------|----------|
| `esprit/agents/EspritAgent/system_prompt.jinja` | Add VULNERABILITY REMEDIATION section after line 101 | HIGH |
| `esprit/agents/EspritAgent/system_prompt.jinja` | Add WHITE-BOX FIXING IS MANDATORY rule at line ~280 | HIGH |
| `esprit/agents/EspritAgent/system_prompt.jinja` | Update white-box workflow diagram (lines 261-270) | HIGH |
| `esprit/skills/vulnerabilities/remediation.md` | Create new skill file | HIGH |
| `esprit/skills/__init__.py` | No change needed (auto-discovers .md files in category dirs) | NONE |
| `esprit/tools/file_edit/*` | No change needed (tool is fully functional) | NONE |
| `esprit/tools/registry.py` | No change needed (tool is registered and schema'd) | NONE |
| `esprit/agents/base_agent.py` | No change needed (tools are passed to LLM) | NONE |

---

## Data Flow Diagram

```
CURRENT FLOW (broken):
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│  Discovery   │───▶│  Validation  │───▶│  Reporting   │───▶ agent_finish
│    Agent     │    │    Agent     │    │    Agent     │     (STOPS)
│              │    │              │    │ create_vuln_ │
│ finds vuln   │    │ proves PoC   │    │ report()     │
└──────────────┘    └──────────────┘    └──────────────┘
                                               │
                                               ✗ No Fixing Agent spawned
                                               ✗ str_replace_editor never called
                                               ✗ Code left vulnerable


PROPOSED FLOW (fixed):
┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│  Discovery   │───▶│  Validation  │───▶│  Reporting   │───▶│   Fixing     │
│    Agent     │    │    Agent     │    │    Agent     │    │    Agent     │
│              │    │              │    │ create_vuln_ │    │ str_replace_ │
│ finds vuln   │    │ proves PoC   │    │ report()     │    │ editor()     │
└──────────────┘    └──────────────┘    └──────────────┘    │ re-run PoC   │
                                                            │ confirm fix  │
                                                            └──────────────┘
                                                                   │
                                                                   ✓ Code patched
                                                                   ✓ Fix verified
                                                                   ✓ Diff in report
```
